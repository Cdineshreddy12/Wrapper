import { pgTable, index, pgEnum, uuid, varchar, text, timestamp, jsonb, boolean, integer, numeric, uniqueIndex, serial } from "drizzle-orm/pg-core"
  import { sql } from "drizzle-orm"

export const aalLevel = pgEnum("aal_level", ['aal1', 'aal2', 'aal3'])
export const codeChallengeMethod = pgEnum("code_challenge_method", ['s256', 'plain'])
export const factorStatus = pgEnum("factor_status", ['unverified', 'verified'])
export const factorType = pgEnum("factor_type", ['totp', 'webauthn', 'phone'])
export const oneTimeTokenType = pgEnum("one_time_token_type", ['confirmation_token', 'reauthentication_token', 'recovery_token', 'email_change_token_new', 'email_change_token_current', 'phone_change_token'])
export const action = pgEnum("action", ['INSERT', 'UPDATE', 'DELETE', 'TRUNCATE', 'ERROR'])
export const equalityOp = pgEnum("equality_op", ['eq', 'neq', 'lt', 'lte', 'gt', 'gte', 'in'])
export const buckettype = pgEnum("buckettype", ['STANDARD', 'ANALYTICS'])
export const oauthRegistrationType = pgEnum("oauth_registration_type", ['dynamic', 'manual'])
export const oauthAuthorizationStatus = pgEnum("oauth_authorization_status", ['pending', 'approved', 'denied', 'expired'])
export const oauthResponseType = pgEnum("oauth_response_type", ['code'])
export const oauthClientType = pgEnum("oauth_client_type", ['public', 'confidential'])


export const webhookLogs = pgTable("webhook_logs", {
	id: uuid("id").defaultRandom().notNull(),
	eventId: varchar("event_id", { length: 255 }).notNull(),
	eventType: varchar("event_type", { length: 100 }).notNull(),
	status: varchar("status", { length: 50 }).notNull(),
	errorMessage: text("error_message"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
},
(table) => {
	return {
		eventIdIdx: index("webhook_logs_event_id_idx").on(table.eventId),
		eventTypeIdx: index("webhook_logs_event_type_idx").on(table.eventType),
		statusIdx: index("webhook_logs_status_idx").on(table.status),
		createdAtIdx: index("webhook_logs_created_at_idx").on(table.createdAt),
	}
});

export const eventTracking = pgTable("event_tracking", {
	trackingId: uuid("tracking_id").defaultRandom().notNull(),
	eventId: text("event_id").notNull(),
	eventType: text("event_type").notNull(),
	tenantId: text("tenant_id").notNull(),
	entityId: text("entity_id"),
	streamKey: text("stream_key").notNull(),
	eventData: jsonb("event_data"),
	publishedAt: timestamp("published_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	publishedBy: text("published_by"),
	acknowledged: boolean("acknowledged").default(false).notNull(),
	acknowledgedAt: timestamp("acknowledged_at", { withTimezone: true, mode: 'string' }),
	acknowledgmentData: jsonb("acknowledgment_data"),
	status: text("status").default('published').notNull(),
	errorMessage: text("error_message"),
	retryCount: integer("retry_count").default(0).notNull(),
	lastRetryAt: timestamp("last_retry_at", { withTimezone: true, mode: 'string' }),
	metadata: jsonb("metadata"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	sourceApplication: text("source_application").default('wrapper').notNull(),
	targetApplication: text("target_application").notNull(),
},
(table) => {
	return {
		idxEventTrackingTenant: index("idx_event_tracking_tenant").on(table.tenantId),
		idxEventTrackingEventId: index("idx_event_tracking_event_id").on(table.eventId),
		idxEventTrackingStatus: index("idx_event_tracking_status").on(table.status),
		idxEventTrackingAcknowledged: index("idx_event_tracking_acknowledged").on(table.acknowledged),
		idxEventTrackingPublishedAt: index("idx_event_tracking_published_at").on(table.publishedAt),
		idxEventTrackingAcknowledgedAt: index("idx_event_tracking_acknowledged_at").on(table.acknowledgedAt),
		idxEventTrackingSourceApp: index("idx_event_tracking_source_app").on(table.sourceApplication),
		idxEventTrackingTargetApp: index("idx_event_tracking_target_app").on(table.targetApplication),
	}
});

export const tenants = pgTable("tenants", {
	tenantId: uuid("tenant_id").defaultRandom().notNull(),
	companyName: varchar("company_name", { length: 255 }).notNull(),
	subdomain: varchar("subdomain", { length: 100 }).notNull(),
	kindeOrgId: varchar("kinde_org_id", { length: 255 }).notNull(),
	adminEmail: varchar("admin_email", { length: 255 }).notNull(),
	legalCompanyName: varchar("legal_company_name", { length: 255 }),
	gstin: varchar("gstin", { length: 15 }),
	companyType: varchar("company_type", { length: 100 }),
	industry: varchar("industry", { length: 100 }),
	website: varchar("website", { length: 500 }),
	billingStreet: varchar("billing_street", { length: 255 }),
	billingCity: varchar("billing_city", { length: 100 }),
	billingState: varchar("billing_state", { length: 100 }),
	billingZip: varchar("billing_zip", { length: 20 }),
	billingCountry: varchar("billing_country", { length: 100 }),
	phone: varchar("phone", { length: 50 }),
	defaultLanguage: varchar("default_language", { length: 10 }).default('en'::character varying),
	defaultLocale: varchar("default_locale", { length: 20 }).default('en-US'::character varying),
	defaultCurrency: varchar("default_currency", { length: 3 }).default('USD'::character varying),
	defaultTimezone: varchar("default_timezone", { length: 50 }).default('UTC'::character varying),
	logoUrl: varchar("logo_url", { length: 500 }),
	primaryColor: varchar("primary_color", { length: 7 }).default('#2563eb'::character varying),
	customDomain: varchar("custom_domain", { length: 255 }),
	brandingConfig: jsonb("branding_config").default({}),
	isActive: boolean("is_active").default(true),
	isVerified: boolean("is_verified").default(false),
	settings: jsonb("settings").default({}),
	stripeCustomerId: varchar("stripe_customer_id", { length: 255 }),
	onboardingCompleted: boolean("onboarding_completed").default(false),
	onboardedAt: timestamp("onboarded_at", { mode: 'string' }),
	onboardingStartedAt: timestamp("onboarding_started_at", { mode: 'string' }),
	trialEndsAt: timestamp("trial_ends_at", { mode: 'string' }),
	trialStartedAt: timestamp("trial_started_at", { mode: 'string' }),
	firstLoginAt: timestamp("first_login_at", { mode: 'string' }),
	lastActivityAt: timestamp("last_activity_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const onboardingEvents = pgTable("onboarding_events", {
	eventId: uuid("event_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	eventType: varchar("event_type", { length: 100 }).notNull(),
	eventPhase: varchar("event_phase", { length: 50 }).notNull(),
	eventAction: varchar("event_action", { length: 50 }).notNull(),
	userId: uuid("user_id"),
	sessionId: varchar("session_id", { length: 255 }),
	ipAddress: varchar("ip_address", { length: 45 }),
	userAgent: text("user_agent"),
	eventData: jsonb("event_data").default({}),
	metadata: jsonb("metadata").default({}),
	timeSpent: integer("time_spent"),
	completionRate: integer("completion_rate"),
	stepNumber: integer("step_number"),
	totalSteps: integer("total_steps"),
	variantId: varchar("variant_id", { length: 50 }),
	experimentId: varchar("experiment_id", { length: 50 }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	eventTimestamp: timestamp("event_timestamp", { mode: 'string' }).defaultNow(),
});

export const tenantInvitations = pgTable("tenant_invitations", {
	invitationId: uuid("invitation_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	email: varchar("email", { length: 255 }).notNull(),
	roleId: uuid("role_id"),
	invitedBy: uuid("invited_by").notNull(),
	invitationToken: varchar("invitation_token", { length: 255 }).notNull(),
	invitationUrl: varchar("invitation_url", { length: 1000 }),
	status: varchar("status", { length: 20 }).default('pending'::character varying),
	expiresAt: timestamp("expires_at", { mode: 'string' }).notNull(),
	acceptedAt: timestamp("accepted_at", { mode: 'string' }),
	cancelledAt: timestamp("cancelled_at", { mode: 'string' }),
	cancelledBy: uuid("cancelled_by"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	targetEntities: jsonb("target_entities").default([]),
	invitationScope: varchar("invitation_scope", { length: 20 }).default('tenant'::character varying),
	primaryEntityId: uuid("primary_entity_id"),
},
(table) => {
	return {
		idxTenantInvitationsScope: index("idx_tenant_invitations_scope").on(table.invitationScope),
		idxTenantInvitationsPrimaryEntity: index("idx_tenant_invitations_primary_entity").on(table.primaryEntityId),
		idxTenantInvitationsPendingMulti: index("idx_tenant_invitations_pending_multi").on(table.invitationToken, table.expiresAt),
	}
});

export const auditLogs = pgTable("audit_logs", {
	logId: uuid("log_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	userId: uuid("user_id"),
	organizationId: uuid("organization_id"),
	locationId: uuid("location_id"),
	entityType: varchar("entity_type", { length: 20 }).default('organization'::character varying),
	accessLevel: varchar("access_level", { length: 20 }).default('direct'::character varying),
	action: varchar("action", { length: 100 }).notNull(),
	resourceType: varchar("resource_type", { length: 50 }).notNull(),
	resourceId: varchar("resource_id", { length: 255 }),
	oldValues: jsonb("old_values"),
	newValues: jsonb("new_values"),
	details: jsonb("details"),
	ipAddress: varchar("ip_address", { length: 45 }),
	userAgent: text("user_agent"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const creditAllocationsBackup = pgTable("credit_allocations_backup", {
	allocationId: uuid("allocation_id"),
	tenantId: uuid("tenant_id"),
	sourceEntityId: uuid("source_entity_id"),
	targetApplication: varchar("target_application", { length: 50 }),
	allocatedCredits: numeric("allocated_credits", { precision: 15, scale:  4 }),
	usedCredits: numeric("used_credits", { precision: 15, scale:  4 }),
	availableCredits: numeric("available_credits", { precision: 15, scale:  4 }),
	allocationType: varchar("allocation_type", { length: 30 }),
	allocationPurpose: text("allocation_purpose"),
	isActive: boolean("is_active"),
	allocatedAt: timestamp("allocated_at", { mode: 'string' }),
	expiresAt: timestamp("expires_at", { mode: 'string' }),
	autoReplenish: boolean("auto_replenish"),
	allocatedBy: uuid("allocated_by"),
	lastUpdatedAt: timestamp("last_updated_at", { mode: 'string' }),
	updatedBy: uuid("updated_by"),
	creditType: varchar("credit_type", { length: 20 }),
});

export const responsibilityNotifications = pgTable("responsibility_notifications", {
	notificationId: uuid("notification_id").defaultRandom().notNull(),
	assignmentId: uuid("assignment_id").notNull(),
	notificationType: varchar("notification_type", { length: 50 }).notNull(),
	title: varchar("title", { length: 255 }).notNull(),
	message: text("message").notNull(),
	priority: varchar("priority", { length: 20 }).default('normal'::character varying),
	actionRequired: varchar("action_required", { length: 100 }),
	actionUrl: varchar("action_url", { length: 500 }),
	actionDeadline: timestamp("action_deadline", { mode: 'string' }),
	sentAt: timestamp("sent_at", { mode: 'string' }),
	deliveredAt: timestamp("delivered_at", { mode: 'string' }),
	readAt: timestamp("read_at", { mode: 'string' }),
	status: varchar("status", { length: 20 }).default('pending'::character varying),
	retryCount: integer("retry_count").default(0),
	maxRetries: integer("max_retries").default(3),
	nextRetryAt: timestamp("next_retry_at", { mode: 'string' }),
	metadata: jsonb("metadata").default({}),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const tenantUsers = pgTable("tenant_users", {
	userId: uuid("user_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	kindeUserId: varchar("kinde_user_id", { length: 255 }),
	email: varchar("email", { length: 255 }).notNull(),
	name: varchar("name", { length: 255 }).notNull(),
	firstName: varchar("first_name", { length: 100 }),
	lastName: varchar("last_name", { length: 100 }),
	username: varchar("username", { length: 100 }),
	avatar: varchar("avatar", { length: 500 }),
	title: varchar("title", { length: 100 }),
	department: varchar("department", { length: 100 }),
	alias: varchar("alias", { length: 100 }),
	phone: varchar("phone", { length: 50 }),
	mobile: varchar("mobile", { length: 50 }),
	profileData: jsonb("profile_data").default({}),
	primaryOrganizationId: uuid("primary_organization_id"),
	isResponsiblePerson: boolean("is_responsible_person").default(false),
	adminPrivileges: jsonb("admin_privileges").default({}),
	isActive: boolean("is_active").default(true),
	isVerified: boolean("is_verified").default(false),
	isTenantAdmin: boolean("is_tenant_admin").default(false),
	invitedAt: timestamp("invited_at", { mode: 'string' }),
	lastActiveAt: timestamp("last_active_at", { mode: 'string' }),
	lastLoginAt: timestamp("last_login_at", { mode: 'string' }),
	loginCount: integer("login_count").default(0),
	preferences: jsonb("preferences").default({}),
	onboardingCompleted: boolean("onboarding_completed").default(false),
	onboardingStep: varchar("onboarding_step", { length: 50 }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const userManagerRelationships = pgTable("user_manager_relationships", {
	relationshipId: uuid("relationship_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	userId: uuid("user_id").notNull(),
	managerId: uuid("manager_id").notNull(),
	relationshipType: varchar("relationship_type", { length: 50 }).default('direct'::character varying),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const userSessions = pgTable("user_sessions", {
	sessionId: uuid("session_id").defaultRandom().notNull(),
	userId: uuid("user_id").notNull(),
	tenantId: uuid("tenant_id").notNull(),
	sessionToken: varchar("session_token", { length: 255 }).notNull(),
	ipAddress: varchar("ip_address", { length: 45 }),
	userAgent: text("user_agent"),
	loginAt: timestamp("login_at", { mode: 'string' }).defaultNow(),
	lastActivityAt: timestamp("last_activity_at", { mode: 'string' }).defaultNow(),
	expiresAt: timestamp("expires_at", { mode: 'string' }).notNull(),
	isActive: boolean("is_active").default(true),
});

export const payments = pgTable("payments", {
	paymentId: uuid("payment_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	subscriptionId: uuid("subscription_id"),
	stripePaymentIntentId: varchar("stripe_payment_intent_id", { length: 255 }),
	stripeInvoiceId: varchar("stripe_invoice_id", { length: 255 }),
	stripeChargeId: varchar("stripe_charge_id", { length: 255 }),
	amount: numeric("amount", { precision: 10, scale:  2 }).notNull(),
	currency: varchar("currency", { length: 3 }).default('USD'::character varying),
	status: varchar("status", { length: 20 }).notNull(),
	paymentMethod: varchar("payment_method", { length: 50 }),
	paymentMethodDetails: jsonb("payment_method_details").default({}),
	paymentType: varchar("payment_type", { length: 30 }).default('subscription'::character varying),
	billingReason: varchar("billing_reason", { length: 50 }),
	invoiceNumber: varchar("invoice_number", { length: 50 }),
	description: text("description"),
	prorationAmount: numeric("proration_amount", { precision: 10, scale:  2 }).default('0'),
	creditAmount: numeric("credit_amount", { precision: 10, scale:  2 }).default('0'),
	taxAmount: numeric("tax_amount", { precision: 10, scale:  2 }).default('0'),
	taxRate: numeric("tax_rate", { precision: 5, scale:  4 }).default('0'),
	taxRegion: varchar("tax_region", { length: 50 }),
	processingFees: numeric("processing_fees", { precision: 10, scale:  2 }).default('0'),
	netAmount: numeric("net_amount", { precision: 10, scale:  2 }),
	metadata: jsonb("metadata").default({}),
	stripeRawData: jsonb("stripe_raw_data").default({}),
	paidAt: timestamp("paid_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const subscriptions = pgTable("subscriptions", {
	subscriptionId: uuid("subscription_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	plan: varchar("plan", { length: 50 }).notNull(),
	status: varchar("status", { length: 20 }).notNull(),
	stripeSubscriptionId: varchar("stripe_subscription_id", { length: 255 }),
	stripeCustomerId: varchar("stripe_customer_id", { length: 255 }),
	isTrialUser: boolean("is_trial_user").default(false),
	hasEverUpgraded: boolean("has_ever_upgraded").default(false),
	subscribedTools: jsonb("subscribed_tools").default([]),
	usageLimits: jsonb("usage_limits").default({}),
	billingCycle: varchar("billing_cycle", { length: 20 }).default('monthly'::character varying),
	yearlyPrice: numeric("yearly_price", { precision: 10, scale:  2 }).default('0'),
	currentPeriodStart: timestamp("current_period_start", { mode: 'string' }),
	currentPeriodEnd: timestamp("current_period_end", { mode: 'string' }),
	cancelAt: timestamp("cancel_at", { mode: 'string' }),
	canceledAt: timestamp("canceled_at", { mode: 'string' }),
	suspendedAt: timestamp("suspended_at", { mode: 'string' }),
	suspendedReason: text("suspended_reason"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const entities = pgTable("entities", {
	entityId: uuid("entity_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	entityType: varchar("entity_type", { length: 20 }).notNull(),
	parentEntityId: uuid("parent_entity_id"),
	entityLevel: integer("entity_level").default(1),
	entityName: varchar("entity_name", { length: 255 }).notNull(),
	entityCode: varchar("entity_code", { length: 50 }),
	description: text("description"),
	organizationType: varchar("organization_type", { length: 20 }),
	locationType: varchar("location_type", { length: 20 }),
	departmentType: varchar("department_type", { length: 20 }),
	teamType: varchar("team_type", { length: 20 }),
	address: jsonb("address"),
	coordinates: jsonb("coordinates"),
	businessHours: jsonb("business_hours"),
	capacity: jsonb("capacity"),
	timezone: varchar("timezone", { length: 50 }).default('UTC'::character varying),
	currency: varchar("currency", { length: 3 }).default('USD'::character varying),
	language: varchar("language", { length: 10 }).default('en'::character varying),
	logoUrl: varchar("logo_url", { length: 500 }),
	primaryColor: varchar("primary_color", { length: 7 }),
	brandingConfig: jsonb("branding_config").default({}),
	responsiblePersonId: uuid("responsible_person_id"),
	creditAllocation: numeric("credit_allocation", { precision: 15, scale:  4 }).default('0'),
	creditPolicy: jsonb("credit_policy").default({"allowOverage":true,"overageLimit":10000,"overagePeriod":"day","creditExpiryPolicy":{"enabled":true,"defaultDays":365},"maxCreditAllocation":null,"allowCreditAllocation":true}),
	inheritSettings: boolean("inherit_settings").default(true),
	inheritBranding: boolean("inherit_branding").default(true),
	inheritCredits: boolean("inherit_credits").default(false),
	settings: jsonb("settings").default({"features":{},"autoBackup":true,"notifications":true}),
	isActive: boolean("is_active").default(true),
	isDefault: boolean("is_default").default(false),
	isHeadquarters: boolean("is_headquarters").default(false),
	onboardingCompleted: boolean("onboarding_completed").default(false),
	onboardedAt: timestamp("onboarded_at", { mode: 'string' }),
	hierarchyPath: text("hierarchy_path"),
	fullHierarchyPath: text("full_hierarchy_path"),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
},
(table) => {
	return {
		idxEntitiesHierarchyPath: index("idx_entities_hierarchy_path").on(table.hierarchyPath),
		idxEntitiesParentEntityId: index("idx_entities_parent_entity_id").on(table.parentEntityId),
		idxEntitiesTenantHierarchy: index("idx_entities_tenant_hierarchy").on(table.tenantId, table.parentEntityId, table.entityLevel),
		idxEntitiesTypeHierarchy: index("idx_entities_type_hierarchy").on(table.tenantId, table.entityType, table.parentEntityId),
	}
});

export const customRoles = pgTable("custom_roles", {
	roleId: uuid("role_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	organizationId: uuid("organization_id"),
	locationId: uuid("location_id"),
	scope: varchar("scope", { length: 20 }).default('organization'::character varying),
	isInheritable: boolean("is_inheritable").default(true),
	parentRoleId: uuid("parent_role_id"),
	roleName: varchar("role_name", { length: 100 }).notNull(),
	description: text("description"),
	color: varchar("color", { length: 7 }).default('#6b7280'::character varying),
	kindeRoleId: varchar("kinde_role_id", { length: 255 }),
	kindeRoleKey: varchar("kinde_role_key", { length: 255 }),
	permissions: jsonb("permissions").notNull(),
	restrictions: jsonb("restrictions").default({}),
	isSystemRole: boolean("is_system_role").default(false),
	isDefault: boolean("is_default").default(false),
	priority: integer("priority").default(0),
	createdBy: uuid("created_by").notNull(),
	lastModifiedBy: uuid("last_modified_by"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const userRoleAssignments = pgTable("user_role_assignments", {
	id: uuid("id").defaultRandom().notNull(),
	userId: uuid("user_id").notNull(),
	roleId: uuid("role_id").notNull(),
	organizationId: uuid("organization_id"),
	locationId: uuid("location_id"),
	scope: varchar("scope", { length: 20 }).default('organization'::character varying),
	isResponsiblePerson: boolean("is_responsible_person").default(false),
	inheritedFrom: uuid("inherited_from"),
	assignedBy: uuid("assigned_by").notNull(),
	assignedAt: timestamp("assigned_at", { mode: 'string' }).defaultNow(),
	isTemporary: boolean("is_temporary").default(false),
	expiresAt: timestamp("expires_at", { mode: 'string' }),
	isActive: boolean("is_active").default(true),
	deactivatedAt: timestamp("deactivated_at", { mode: 'string' }),
	deactivatedBy: uuid("deactivated_by"),
});

export const usageLogs = pgTable("usage_logs", {
	logId: uuid("log_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	userId: uuid("user_id"),
	organizationId: uuid("organization_id"),
	locationId: uuid("location_id"),
	app: varchar("app", { length: 50 }).notNull(),
	endpoint: varchar("endpoint", { length: 255 }).notNull(),
	method: varchar("method", { length: 10 }).notNull(),
	statusCode: integer("status_code"),
	responseTime: numeric("response_time", { precision: 8, scale:  2 }),
	source: varchar("source", { length: 50 }).notNull(),
	ipAddress: varchar("ip_address", { length: 45 }),
	userAgent: text("user_agent"),
	operationCode: varchar("operation_code", { length: 255 }),
	creditConsumed: numeric("credit_consumed", { precision: 10, scale:  4 }).default('0'),
	creditBatchId: uuid("credit_batch_id"),
	pricingMode: varchar("pricing_mode", { length: 20 }).default('credits'::character varying),
	requestSize: integer("request_size"),
	responseSize: integer("response_size"),
	metadata: jsonb("metadata").default({}),
	errorMessage: text("error_message"),
	errorStack: text("error_stack"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const usageMetricsDaily = pgTable("usage_metrics_daily", {
	metricId: uuid("metric_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	organizationId: uuid("organization_id"),
	locationId: uuid("location_id"),
	app: varchar("app", { length: 50 }).notNull(),
	date: timestamp("date", { mode: 'string' }).notNull(),
	apiCalls: integer("api_calls").default(0),
	storageUsed: numeric("storage_used", { precision: 15, scale:  2 }).default('0'),
	activeUsers: integer("active_users").default(0),
	totalRequests: integer("total_requests").default(0),
	creditConsumed: numeric("credit_consumed", { precision: 15, scale:  4 }).default('0'),
	creditBatchesUsed: jsonb("credit_batches_used").default([]),
	avgResponseTime: numeric("avg_response_time", { precision: 8, scale:  2 }).default('0'),
	errorCount: integer("error_count").default(0),
	featureUsage: jsonb("feature_usage").default({}),
	usageBySource: jsonb("usage_by_source").default({}),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const applications = pgTable("applications", {
	appId: uuid("app_id").defaultRandom().notNull(),
	appCode: varchar("app_code", { length: 50 }).notNull(),
	appName: varchar("app_name", { length: 100 }).notNull(),
	description: text("description"),
	icon: varchar("icon", { length: 255 }),
	baseUrl: varchar("base_url", { length: 255 }).notNull(),
	status: varchar("status", { length: 20 }).default('active'::character varying).notNull(),
	version: varchar("version", { length: 20 }),
	isCore: boolean("is_core").default(false),
	sortOrder: integer("sort_order").default(0),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const applicationModules = pgTable("application_modules", {
	moduleId: uuid("module_id").defaultRandom().notNull(),
	appId: uuid("app_id"),
	moduleCode: varchar("module_code", { length: 50 }).notNull(),
	moduleName: varchar("module_name", { length: 100 }).notNull(),
	description: text("description"),
	isCore: boolean("is_core").default(false),
	permissions: jsonb("permissions"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const organizationApplications = pgTable("organization_applications", {
	id: uuid("id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id"),
	appId: uuid("app_id"),
	isEnabled: boolean("is_enabled").default(true),
	enabledModules: jsonb("enabled_modules"),
	customPermissions: jsonb("custom_permissions"),
	licenseCount: integer("license_count").default(0),
	maxUsers: integer("max_users"),
	subscriptionTier: varchar("subscription_tier", { length: 50 }),
	expiresAt: timestamp("expires_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
},
(table) => {
	return {
		tenantAppUnique: uniqueIndex("organization_applications_tenant_app_unique").on(table.tenantId, table.appId),
	}
});

export const userApplicationPermissions = pgTable("user_application_permissions", {
	id: uuid("id").defaultRandom().notNull(),
	userId: uuid("user_id"),
	tenantId: uuid("tenant_id"),
	appId: uuid("app_id"),
	moduleId: uuid("module_id"),
	permissions: jsonb("permissions"),
	isActive: boolean("is_active").default(true),
	metadata: jsonb("metadata"),
	grantedBy: uuid("granted_by"),
	grantedAt: timestamp("granted_at", { mode: 'string' }).defaultNow(),
	expiresAt: timestamp("expires_at", { mode: 'string' }),
});

export const organizationMemberships = pgTable("organization_memberships", {
	membershipId: uuid("membership_id").defaultRandom().notNull(),
	userId: uuid("user_id").notNull(),
	tenantId: uuid("tenant_id").notNull(),
	entityId: uuid("entity_id").notNull(),
	entityType: varchar("entity_type", { length: 20 }).default('organization'::character varying),
	roleId: uuid("role_id"),
	roleName: varchar("role_name", { length: 100 }),
	permissions: jsonb("permissions").default({}),
	membershipType: varchar("membership_type", { length: 20 }).default('direct'::character varying),
	membershipStatus: varchar("membership_status", { length: 20 }).default('active'::character varying),
	accessLevel: varchar("access_level", { length: 20 }).default('standard'::character varying),
	isPrimary: boolean("is_primary").default(false),
	canAccessSubEntities: boolean("can_access_sub_entities").default(false),
	creditPermissions: jsonb("credit_permissions").default({"creditLimit":null,"canPurchaseCredits":false,"canTransferCredits":false,"canViewCreditUsage":true,"canApproveTransfers":false}),
	isTemporary: boolean("is_temporary").default(false),
	validFrom: timestamp("valid_from", { mode: 'string' }),
	validUntil: timestamp("valid_until", { mode: 'string' }),
	timezone: varchar("timezone", { length: 50 }).default('UTC'::character varying),
	department: varchar("department", { length: 100 }),
	team: varchar("team", { length: 100 }),
	jobTitle: varchar("job_title", { length: 100 }),
	employeeId: varchar("employee_id", { length: 50 }),
	contactOverride: jsonb("contact_override").default({}),
	preferences: jsonb("preferences").default({"dashboard":{"theme":"default","layout":"standard"},"notifications":{"sms":false,"push":true,"email":true}}),
	invitedBy: uuid("invited_by"),
	invitedAt: timestamp("invited_at", { mode: 'string' }),
	joinedAt: timestamp("joined_at", { mode: 'string' }),
	lastAccessedAt: timestamp("last_accessed_at", { mode: 'string' }),
	notes: text("notes"),
	metadata: jsonb("metadata").default({}),
	createdBy: uuid("created_by").notNull(),
	updatedBy: uuid("updated_by"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const membershipHistory = pgTable("membership_history", {
	historyId: uuid("history_id").defaultRandom().notNull(),
	membershipId: uuid("membership_id").notNull(),
	entityId: uuid("entity_id"),
	changeType: varchar("change_type", { length: 50 }).notNull(),
	oldValues: jsonb("old_values"),
	newValues: jsonb("new_values"),
	changeReason: text("change_reason"),
	changedBy: uuid("changed_by").notNull(),
	changeSource: varchar("change_source", { length: 50 }).default('manual'::character varying),
	metadata: jsonb("metadata").default({}),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const membershipInvitations = pgTable("membership_invitations", {
	invitationId: uuid("invitation_id").defaultRandom().notNull(),
	membershipId: uuid("membership_id"),
	invitedUserId: uuid("invited_user_id"),
	invitedEmail: varchar("invited_email", { length: 255 }).notNull(),
	invitationToken: varchar("invitation_token", { length: 255 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	entityType: varchar("entity_type", { length: 20 }).default('organization'::character varying),
	roleId: uuid("role_id"),
	status: varchar("status", { length: 20 }).default('pending'::character varying),
	sentAt: timestamp("sent_at", { mode: 'string' }),
	expiresAt: timestamp("expires_at", { mode: 'string' }).notNull(),
	acceptedAt: timestamp("accepted_at", { mode: 'string' }),
	declinedAt: timestamp("declined_at", { mode: 'string' }),
	cancelledAt: timestamp("cancelled_at", { mode: 'string' }),
	message: text("message"),
	invitationUrl: varchar("invitation_url", { length: 1000 }),
	invitedBy: uuid("invited_by").notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const creditTransactions = pgTable("credit_transactions", {
	transactionId: uuid("transaction_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	entityId: uuid("entity_id"),
	transactionType: varchar("transaction_type", { length: 30 }).notNull(),
	amount: numeric("amount", { precision: 15, scale:  4 }).notNull(),
	previousBalance: numeric("previous_balance", { precision: 15, scale:  4 }),
	newBalance: numeric("new_balance", { precision: 15, scale:  4 }),
	operationCode: varchar("operation_code", { length: 255 }),
	initiatedBy: uuid("initiated_by"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const credits = pgTable("credits", {
	creditId: uuid("credit_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	entityId: uuid("entity_id"),
	availableCredits: numeric("available_credits", { precision: 15, scale:  4 }).default('0'),
	isActive: boolean("is_active").default(true),
	lastUpdatedAt: timestamp("last_updated_at", { mode: 'string' }).defaultNow(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const creditPurchases = pgTable("credit_purchases", {
	purchaseId: uuid("purchase_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	entityId: uuid("entity_id"),
	creditAmount: numeric("credit_amount", { precision: 15, scale:  4 }).notNull(),
	unitPrice: numeric("unit_price", { precision: 10, scale:  4 }).notNull(),
	totalAmount: numeric("total_amount", { precision: 10, scale:  2 }).notNull(),
	batchId: uuid("batch_id").notNull(),
	expiryDate: timestamp("expiry_date", { mode: 'string' }),
	paymentMethod: varchar("payment_method", { length: 50 }),
	stripePaymentIntentId: varchar("stripe_payment_intent_id", { length: 255 }),
	paymentStatus: varchar("payment_status", { length: 20 }).default('pending'::character varying),
	status: varchar("status", { length: 20 }).default('pending'::character varying),
	requestedAt: timestamp("requested_at", { mode: 'string' }).defaultNow(),
	paidAt: timestamp("paid_at", { mode: 'string' }),
	creditedAt: timestamp("credited_at", { mode: 'string' }),
	requestedBy: uuid("requested_by").notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const creditUsage = pgTable("credit_usage", {
	usageId: uuid("usage_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	entityId: uuid("entity_id").notNull(),
	userId: uuid("user_id"),
	operationCode: varchar("operation_code", { length: 255 }).notNull(),
	operationId: uuid("operation_id"),
	creditsDebited: numeric("credits_debited", { precision: 10, scale:  4 }).notNull(),
	ipAddress: varchar("ip_address", { length: 45 }),
	requestId: varchar("request_id", { length: 100 }),
	success: boolean("success").default(true),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const responsiblePersons = pgTable("responsible_persons", {
	assignmentId: uuid("assignment_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	entityType: varchar("entity_type", { length: 20 }).notNull(),
	entityId: uuid("entity_id"),
	userId: uuid("user_id").notNull(),
	responsibilityLevel: varchar("responsibility_level", { length: 20 }).default('primary'::character varying),
	scope: jsonb("scope").default({"auditAccess":true,"userManagement":true,"reportingAccess":true,"creditManagement":true,"configurationManagement":true}),
	autoPermissions: jsonb("auto_permissions").default({"canManageUsers":true,"canConfigureEntity":true,"canGenerateReports":true,"canPurchaseCredits":true,"canApproveTransfers":true,"canViewAllAuditLogs":true}),
	notificationPreferences: jsonb("notification_preferences").default({"creditAlerts":true,"systemAlerts":true,"weeklyReports":true,"monthlyReports":true,"userActivities":true}),
	assignedBy: uuid("assigned_by").notNull(),
	assignedAt: timestamp("assigned_at", { mode: 'string' }).defaultNow(),
	assignmentReason: text("assignment_reason"),
	isTemporary: boolean("is_temporary").default(false),
	validFrom: timestamp("valid_from", { mode: 'string' }),
	validUntil: timestamp("valid_until", { mode: 'string' }),
	autoExpire: boolean("auto_expire").default(false),
	isActive: boolean("is_active").default(true),
	isConfirmed: boolean("is_confirmed").default(false),
	confirmedAt: timestamp("confirmed_at", { mode: 'string' }),
	canDelegate: boolean("can_delegate").default(false),
	delegationLimits: jsonb("delegation_limits").default({}),
	isEmergencyContact: boolean("is_emergency_contact").default(false),
	emergencyContactOrder: integer("emergency_contact_order"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const responsibilityHistory = pgTable("responsibility_history", {
	historyId: uuid("history_id").defaultRandom().notNull(),
	assignmentId: uuid("assignment_id").notNull(),
	changeType: varchar("change_type", { length: 50 }).notNull(),
	oldValues: jsonb("old_values"),
	newValues: jsonb("new_values"),
	changeReason: text("change_reason"),
	changedBy: uuid("changed_by").notNull(),
	changeSource: varchar("change_source", { length: 50 }).default('manual'::character varying),
	metadata: jsonb("metadata").default({}),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const creditConfigurations = pgTable("credit_configurations", {
	configId: uuid("config_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id"),
	operationCode: varchar("operation_code", { length: 255 }).notNull(),
	isGlobal: boolean("is_global").default(true),
	creditCost: numeric("credit_cost", { precision: 10, scale:  4 }).notNull(),
	unit: varchar("unit", { length: 20 }).default('operation'::character varying),
	unitMultiplier: numeric("unit_multiplier", { precision: 10, scale:  4 }).default('1'),
	isActive: boolean("is_active").default(true),
	createdBy: uuid("created_by").notNull(),
	updatedBy: uuid("updated_by"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	entityId: uuid("entity_id"),
	entityKey: text("entity_key"),
	operationName: varchar("operation_name", { length: 255 }),
	category: varchar("category", { length: 100 }),
	freeAllowance: integer("free_allowance"),
	freeAllowancePeriod: varchar("free_allowance_period", { length: 20 }),
	volumeTiers: varchar("volume_tiers"),
	allowOverage: boolean("allow_overage").default(false),
	overageLimit: integer("overage_limit"),
	overagePeriod: varchar("overage_period", { length: 20 }),
	overageCost: numeric("overage_cost", { precision: 10, scale:  4 }),
	scope: varchar("scope", { length: 20 }).default('global'::character varying),
	priority: integer("priority").default(100),
},
(table) => {
	return {
		uniqueGlobalCreditConfig: uniqueIndex("unique_global_credit_config").on(table.operationCode),
		uniqueTenantCreditConfig: uniqueIndex("unique_tenant_credit_config").on(table.tenantId, table.operationCode),
		idxCreditConfigLookup: index("idx_credit_config_lookup").on(table.tenantId, table.operationCode, table.isActive),
		idxCreditConfigurationsEntityKey: uniqueIndex("idx_credit_configurations_entity_key").on(table.tenantId, table.operationCode, table.entityKey),
	}
});

export const creditAllocations = pgTable("credit_allocations", {
	allocationId: uuid("allocation_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	sourceEntityId: uuid("source_entity_id").notNull(),
	targetApplication: varchar("target_application", { length: 50 }).notNull(),
	allocatedCredits: numeric("allocated_credits", { precision: 15, scale:  4 }).notNull(),
	usedCredits: numeric("used_credits", { precision: 15, scale:  4 }).default('0').notNull(),
	availableCredits: numeric("available_credits", { precision: 15, scale:  4 }).default('0').notNull(),
	allocationType: varchar("allocation_type", { length: 30 }).default('manual'::character varying).notNull(),
	allocationPurpose: text("allocation_purpose"),
	isActive: boolean("is_active").default(true).notNull(),
	allocatedAt: timestamp("allocated_at", { mode: 'string' }).defaultNow().notNull(),
	expiresAt: timestamp("expires_at", { mode: 'string' }),
	autoReplenish: boolean("auto_replenish").default(false).notNull(),
	allocatedBy: uuid("allocated_by"),
	lastUpdatedAt: timestamp("last_updated_at", { mode: 'string' }).defaultNow().notNull(),
	updatedBy: uuid("updated_by"),
	creditType: varchar("credit_type", { length: 50 }).default('free'::character varying),
	creditMetadata: jsonb("credit_metadata"),
	campaignId: varchar("campaign_id", { length: 100 }),
	campaignName: varchar("campaign_name", { length: 255 }),
	expiryRule: varchar("expiry_rule", { length: 50 }).default('fixed_date'::character varying),
	expiryWarningDays: integer("expiry_warning_days").default(7),
},
(table) => {
	return {
		idxCreditAllocationsSeasonalExpiry: index("idx_credit_allocations_seasonal_expiry").on(table.expiresAt, table.creditType),
		tenantActiveIdx: index("credit_allocations_tenant_active_idx").on(table.tenantId, table.isActive),
		tenantAppIdx: index("credit_allocations_tenant_app_idx").on(table.tenantId, table.targetApplication),
		sourceEntityIdx: index("credit_allocations_source_entity_idx").on(table.sourceEntityId),
		idxCreditAllocationsCampaign: index("idx_credit_allocations_campaign").on(table.creditType, table.campaignId),
	}
});

export const creditAllocationTransactions = pgTable("credit_allocation_transactions", {
	transactionId: uuid("transaction_id").defaultRandom().notNull(),
	tenantId: uuid("tenant_id").notNull(),
	allocationId: uuid("allocation_id").notNull(),
	transactionType: varchar("transaction_type", { length: 30 }).notNull(),
	amount: numeric("amount", { precision: 15, scale:  4 }).notNull(),
	previousAllocated: numeric("previous_allocated", { precision: 15, scale:  4 }),
	newAllocated: numeric("new_allocated", { precision: 15, scale:  4 }),
	previousUsed: numeric("previous_used", { precision: 15, scale:  4 }),
	newUsed: numeric("new_used", { precision: 15, scale:  4 }),
	operationCode: varchar("operation_code", { length: 255 }),
	description: text("description"),
	initiatedBy: uuid("initiated_by"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
},
(table) => {
	return {
		allocationIdx: index("credit_allocation_transactions_allocation_idx").on(table.allocationId),
		tenantCreatedIdx: index("credit_allocation_transactions_tenant_created_idx").on(table.tenantId, table.createdAt),
	}
});

export const changeLog = pgTable("change_log", {
	id: serial("id").notNull(),
	tableName: varchar("table_name", { length: 50 }).notNull(),
	recordId: uuid("record_id").notNull(),
	operation: varchar("operation", { length: 10 }).notNull(),
	changedAt: timestamp("changed_at", { mode: 'string' }).defaultNow(),
	changedFields: text("changed_fields"),
	priority: varchar("priority", { length: 20 }).default('normal'::character varying),
	processed: boolean("processed").default(false),
	batchId: uuid("batch_id"),
},
(table) => {
	return {
		idxChangeLogTableTime: index("idx_change_log_table_time").on(table.tableName, table.changedAt),
		idxChangeLogUnprocessed: index("idx_change_log_unprocessed").on(table.processed),
		idxChangeLogPriority: index("idx_change_log_priority").on(table.changedAt, table.priority),
	}
});